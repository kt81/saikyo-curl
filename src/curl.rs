/* automatically generated by rust-bindgen 0.66.1 */

pub type curl_off_t = ::std::os::raw::c_longlong;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type u_int = ::std::os::raw::c_uint;
pub type SOCKET = UINT_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fd_count: u_int,
    pub fd_array: [SOCKET; 64usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        520usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fd_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd_array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fd_array)
        )
    );
}
pub type CURL = ::std::os::raw::c_void;
pub type CURLSH = ::std::os::raw::c_void;
pub type curl_socket_t = SOCKET;
pub const curl_sslbackend_CURLSSLBACKEND_NONE: curl_sslbackend = 0;
pub const curl_sslbackend_CURLSSLBACKEND_OPENSSL: curl_sslbackend = 1;
pub const curl_sslbackend_CURLSSLBACKEND_GNUTLS: curl_sslbackend = 2;
pub const curl_sslbackend_CURLSSLBACKEND_NSS: curl_sslbackend = 3;
pub const curl_sslbackend_CURLSSLBACKEND_OBSOLETE4: curl_sslbackend = 4;
pub const curl_sslbackend_CURLSSLBACKEND_GSKIT: curl_sslbackend = 5;
pub const curl_sslbackend_CURLSSLBACKEND_POLARSSL: curl_sslbackend = 6;
pub const curl_sslbackend_CURLSSLBACKEND_WOLFSSL: curl_sslbackend = 7;
pub const curl_sslbackend_CURLSSLBACKEND_SCHANNEL: curl_sslbackend = 8;
pub const curl_sslbackend_CURLSSLBACKEND_SECURETRANSPORT: curl_sslbackend = 9;
pub const curl_sslbackend_CURLSSLBACKEND_AXTLS: curl_sslbackend = 10;
pub const curl_sslbackend_CURLSSLBACKEND_MBEDTLS: curl_sslbackend = 11;
pub const curl_sslbackend_CURLSSLBACKEND_MESALINK: curl_sslbackend = 12;
pub const curl_sslbackend_CURLSSLBACKEND_BEARSSL: curl_sslbackend = 13;
pub const curl_sslbackend_CURLSSLBACKEND_RUSTLS: curl_sslbackend = 14;
pub type curl_sslbackend = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_httppost {
    pub next: *mut curl_httppost,
    pub name: *mut ::std::os::raw::c_char,
    pub namelength: ::std::os::raw::c_long,
    pub contents: *mut ::std::os::raw::c_char,
    pub contentslength: ::std::os::raw::c_long,
    pub buffer: *mut ::std::os::raw::c_char,
    pub bufferlength: ::std::os::raw::c_long,
    pub contenttype: *mut ::std::os::raw::c_char,
    pub contentheader: *mut curl_slist,
    pub more: *mut curl_httppost,
    pub flags: ::std::os::raw::c_long,
    pub showfilename: *mut ::std::os::raw::c_char,
    pub userp: *mut ::std::os::raw::c_void,
    pub contentlen: curl_off_t,
}
#[test]
fn bindgen_test_layout_curl_httppost() {
    const UNINIT: ::std::mem::MaybeUninit<curl_httppost> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_httppost>(),
        112usize,
        concat!("Size of: ", stringify!(curl_httppost))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_httppost>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_httppost))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(namelength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contents) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentslength) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(contentslength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferlength) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(bufferlength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contenttype) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(contenttype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentheader) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(contentheader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).more) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(more)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).showfilename) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(showfilename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userp) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(userp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentlen) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_httppost),
            "::",
            stringify!(contentlen)
        )
    );
}
pub type curl_seek_callback = ::std::option::Option<
    unsafe extern "C" fn(
        instream: *mut ::std::os::raw::c_void,
        offset: curl_off_t,
        origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type curl_read_callback = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        nitems: usize,
        instream: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type curl_malloc_callback =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type curl_free_callback =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
pub type curl_realloc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type curl_strdup_callback = ::std::option::Option<
    unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type curl_calloc_callback = ::std::option::Option<
    unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void,
>;
pub const CURLcode_CURLE_OK: CURLcode = 0;
pub const CURLcode_CURLE_UNSUPPORTED_PROTOCOL: CURLcode = 1;
pub const CURLcode_CURLE_FAILED_INIT: CURLcode = 2;
pub const CURLcode_CURLE_URL_MALFORMAT: CURLcode = 3;
pub const CURLcode_CURLE_NOT_BUILT_IN: CURLcode = 4;
pub const CURLcode_CURLE_COULDNT_RESOLVE_PROXY: CURLcode = 5;
pub const CURLcode_CURLE_COULDNT_RESOLVE_HOST: CURLcode = 6;
pub const CURLcode_CURLE_COULDNT_CONNECT: CURLcode = 7;
pub const CURLcode_CURLE_WEIRD_SERVER_REPLY: CURLcode = 8;
pub const CURLcode_CURLE_REMOTE_ACCESS_DENIED: CURLcode = 9;
pub const CURLcode_CURLE_FTP_ACCEPT_FAILED: CURLcode = 10;
pub const CURLcode_CURLE_FTP_WEIRD_PASS_REPLY: CURLcode = 11;
pub const CURLcode_CURLE_FTP_ACCEPT_TIMEOUT: CURLcode = 12;
pub const CURLcode_CURLE_FTP_WEIRD_PASV_REPLY: CURLcode = 13;
pub const CURLcode_CURLE_FTP_WEIRD_227_FORMAT: CURLcode = 14;
pub const CURLcode_CURLE_FTP_CANT_GET_HOST: CURLcode = 15;
pub const CURLcode_CURLE_HTTP2: CURLcode = 16;
pub const CURLcode_CURLE_FTP_COULDNT_SET_TYPE: CURLcode = 17;
pub const CURLcode_CURLE_PARTIAL_FILE: CURLcode = 18;
pub const CURLcode_CURLE_FTP_COULDNT_RETR_FILE: CURLcode = 19;
pub const CURLcode_CURLE_OBSOLETE20: CURLcode = 20;
pub const CURLcode_CURLE_QUOTE_ERROR: CURLcode = 21;
pub const CURLcode_CURLE_HTTP_RETURNED_ERROR: CURLcode = 22;
pub const CURLcode_CURLE_WRITE_ERROR: CURLcode = 23;
pub const CURLcode_CURLE_OBSOLETE24: CURLcode = 24;
pub const CURLcode_CURLE_UPLOAD_FAILED: CURLcode = 25;
pub const CURLcode_CURLE_READ_ERROR: CURLcode = 26;
pub const CURLcode_CURLE_OUT_OF_MEMORY: CURLcode = 27;
pub const CURLcode_CURLE_OPERATION_TIMEDOUT: CURLcode = 28;
pub const CURLcode_CURLE_OBSOLETE29: CURLcode = 29;
pub const CURLcode_CURLE_FTP_PORT_FAILED: CURLcode = 30;
pub const CURLcode_CURLE_FTP_COULDNT_USE_REST: CURLcode = 31;
pub const CURLcode_CURLE_OBSOLETE32: CURLcode = 32;
pub const CURLcode_CURLE_RANGE_ERROR: CURLcode = 33;
pub const CURLcode_CURLE_HTTP_POST_ERROR: CURLcode = 34;
pub const CURLcode_CURLE_SSL_CONNECT_ERROR: CURLcode = 35;
pub const CURLcode_CURLE_BAD_DOWNLOAD_RESUME: CURLcode = 36;
pub const CURLcode_CURLE_FILE_COULDNT_READ_FILE: CURLcode = 37;
pub const CURLcode_CURLE_LDAP_CANNOT_BIND: CURLcode = 38;
pub const CURLcode_CURLE_LDAP_SEARCH_FAILED: CURLcode = 39;
pub const CURLcode_CURLE_OBSOLETE40: CURLcode = 40;
pub const CURLcode_CURLE_FUNCTION_NOT_FOUND: CURLcode = 41;
pub const CURLcode_CURLE_ABORTED_BY_CALLBACK: CURLcode = 42;
pub const CURLcode_CURLE_BAD_FUNCTION_ARGUMENT: CURLcode = 43;
pub const CURLcode_CURLE_OBSOLETE44: CURLcode = 44;
pub const CURLcode_CURLE_INTERFACE_FAILED: CURLcode = 45;
pub const CURLcode_CURLE_OBSOLETE46: CURLcode = 46;
pub const CURLcode_CURLE_TOO_MANY_REDIRECTS: CURLcode = 47;
pub const CURLcode_CURLE_UNKNOWN_OPTION: CURLcode = 48;
pub const CURLcode_CURLE_SETOPT_OPTION_SYNTAX: CURLcode = 49;
pub const CURLcode_CURLE_OBSOLETE50: CURLcode = 50;
pub const CURLcode_CURLE_OBSOLETE51: CURLcode = 51;
pub const CURLcode_CURLE_GOT_NOTHING: CURLcode = 52;
pub const CURLcode_CURLE_SSL_ENGINE_NOTFOUND: CURLcode = 53;
pub const CURLcode_CURLE_SSL_ENGINE_SETFAILED: CURLcode = 54;
pub const CURLcode_CURLE_SEND_ERROR: CURLcode = 55;
pub const CURLcode_CURLE_RECV_ERROR: CURLcode = 56;
pub const CURLcode_CURLE_OBSOLETE57: CURLcode = 57;
pub const CURLcode_CURLE_SSL_CERTPROBLEM: CURLcode = 58;
pub const CURLcode_CURLE_SSL_CIPHER: CURLcode = 59;
pub const CURLcode_CURLE_PEER_FAILED_VERIFICATION: CURLcode = 60;
pub const CURLcode_CURLE_BAD_CONTENT_ENCODING: CURLcode = 61;
pub const CURLcode_CURLE_OBSOLETE62: CURLcode = 62;
pub const CURLcode_CURLE_FILESIZE_EXCEEDED: CURLcode = 63;
pub const CURLcode_CURLE_USE_SSL_FAILED: CURLcode = 64;
pub const CURLcode_CURLE_SEND_FAIL_REWIND: CURLcode = 65;
pub const CURLcode_CURLE_SSL_ENGINE_INITFAILED: CURLcode = 66;
pub const CURLcode_CURLE_LOGIN_DENIED: CURLcode = 67;
pub const CURLcode_CURLE_TFTP_NOTFOUND: CURLcode = 68;
pub const CURLcode_CURLE_TFTP_PERM: CURLcode = 69;
pub const CURLcode_CURLE_REMOTE_DISK_FULL: CURLcode = 70;
pub const CURLcode_CURLE_TFTP_ILLEGAL: CURLcode = 71;
pub const CURLcode_CURLE_TFTP_UNKNOWNID: CURLcode = 72;
pub const CURLcode_CURLE_REMOTE_FILE_EXISTS: CURLcode = 73;
pub const CURLcode_CURLE_TFTP_NOSUCHUSER: CURLcode = 74;
pub const CURLcode_CURLE_OBSOLETE75: CURLcode = 75;
pub const CURLcode_CURLE_OBSOLETE76: CURLcode = 76;
pub const CURLcode_CURLE_SSL_CACERT_BADFILE: CURLcode = 77;
pub const CURLcode_CURLE_REMOTE_FILE_NOT_FOUND: CURLcode = 78;
pub const CURLcode_CURLE_SSH: CURLcode = 79;
pub const CURLcode_CURLE_SSL_SHUTDOWN_FAILED: CURLcode = 80;
pub const CURLcode_CURLE_AGAIN: CURLcode = 81;
pub const CURLcode_CURLE_SSL_CRL_BADFILE: CURLcode = 82;
pub const CURLcode_CURLE_SSL_ISSUER_ERROR: CURLcode = 83;
pub const CURLcode_CURLE_FTP_PRET_FAILED: CURLcode = 84;
pub const CURLcode_CURLE_RTSP_CSEQ_ERROR: CURLcode = 85;
pub const CURLcode_CURLE_RTSP_SESSION_ERROR: CURLcode = 86;
pub const CURLcode_CURLE_FTP_BAD_FILE_LIST: CURLcode = 87;
pub const CURLcode_CURLE_CHUNK_FAILED: CURLcode = 88;
pub const CURLcode_CURLE_NO_CONNECTION_AVAILABLE: CURLcode = 89;
pub const CURLcode_CURLE_SSL_PINNEDPUBKEYNOTMATCH: CURLcode = 90;
pub const CURLcode_CURLE_SSL_INVALIDCERTSTATUS: CURLcode = 91;
pub const CURLcode_CURLE_HTTP2_STREAM: CURLcode = 92;
pub const CURLcode_CURLE_RECURSIVE_API_CALL: CURLcode = 93;
pub const CURLcode_CURLE_AUTH_ERROR: CURLcode = 94;
pub const CURLcode_CURLE_HTTP3: CURLcode = 95;
pub const CURLcode_CURLE_QUIC_CONNECT_ERROR: CURLcode = 96;
pub const CURLcode_CURLE_PROXY: CURLcode = 97;
pub const CURLcode_CURLE_SSL_CLIENTCERT: CURLcode = 98;
pub const CURLcode_CURLE_UNRECOVERABLE_POLL: CURLcode = 99;
pub const CURLcode_CURL_LAST: CURLcode = 100;
pub type CURLcode = ::std::os::raw::c_int;
pub const CURLoption_CURLOPT_WRITEDATA: CURLoption = 10001;
pub const CURLoption_CURLOPT_URL: CURLoption = 10002;
pub const CURLoption_CURLOPT_PORT: CURLoption = 3;
pub const CURLoption_CURLOPT_PROXY: CURLoption = 10004;
pub const CURLoption_CURLOPT_USERPWD: CURLoption = 10005;
pub const CURLoption_CURLOPT_PROXYUSERPWD: CURLoption = 10006;
pub const CURLoption_CURLOPT_RANGE: CURLoption = 10007;
pub const CURLoption_CURLOPT_READDATA: CURLoption = 10009;
pub const CURLoption_CURLOPT_ERRORBUFFER: CURLoption = 10010;
pub const CURLoption_CURLOPT_WRITEFUNCTION: CURLoption = 20011;
pub const CURLoption_CURLOPT_READFUNCTION: CURLoption = 20012;
pub const CURLoption_CURLOPT_TIMEOUT: CURLoption = 13;
pub const CURLoption_CURLOPT_INFILESIZE: CURLoption = 14;
pub const CURLoption_CURLOPT_POSTFIELDS: CURLoption = 10015;
pub const CURLoption_CURLOPT_REFERER: CURLoption = 10016;
pub const CURLoption_CURLOPT_FTPPORT: CURLoption = 10017;
pub const CURLoption_CURLOPT_USERAGENT: CURLoption = 10018;
pub const CURLoption_CURLOPT_LOW_SPEED_LIMIT: CURLoption = 19;
pub const CURLoption_CURLOPT_LOW_SPEED_TIME: CURLoption = 20;
pub const CURLoption_CURLOPT_RESUME_FROM: CURLoption = 21;
pub const CURLoption_CURLOPT_COOKIE: CURLoption = 10022;
pub const CURLoption_CURLOPT_HTTPHEADER: CURLoption = 10023;
pub const CURLoption_CURLOPT_HTTPPOST: CURLoption = 10024;
pub const CURLoption_CURLOPT_SSLCERT: CURLoption = 10025;
pub const CURLoption_CURLOPT_KEYPASSWD: CURLoption = 10026;
pub const CURLoption_CURLOPT_CRLF: CURLoption = 27;
pub const CURLoption_CURLOPT_QUOTE: CURLoption = 10028;
pub const CURLoption_CURLOPT_HEADERDATA: CURLoption = 10029;
pub const CURLoption_CURLOPT_COOKIEFILE: CURLoption = 10031;
pub const CURLoption_CURLOPT_SSLVERSION: CURLoption = 32;
pub const CURLoption_CURLOPT_TIMECONDITION: CURLoption = 33;
pub const CURLoption_CURLOPT_TIMEVALUE: CURLoption = 34;
pub const CURLoption_CURLOPT_CUSTOMREQUEST: CURLoption = 10036;
pub const CURLoption_CURLOPT_STDERR: CURLoption = 10037;
pub const CURLoption_CURLOPT_POSTQUOTE: CURLoption = 10039;
pub const CURLoption_CURLOPT_OBSOLETE40: CURLoption = 10040;
pub const CURLoption_CURLOPT_VERBOSE: CURLoption = 41;
pub const CURLoption_CURLOPT_HEADER: CURLoption = 42;
pub const CURLoption_CURLOPT_NOPROGRESS: CURLoption = 43;
pub const CURLoption_CURLOPT_NOBODY: CURLoption = 44;
pub const CURLoption_CURLOPT_FAILONERROR: CURLoption = 45;
pub const CURLoption_CURLOPT_UPLOAD: CURLoption = 46;
pub const CURLoption_CURLOPT_POST: CURLoption = 47;
pub const CURLoption_CURLOPT_DIRLISTONLY: CURLoption = 48;
pub const CURLoption_CURLOPT_APPEND: CURLoption = 50;
pub const CURLoption_CURLOPT_NETRC: CURLoption = 51;
pub const CURLoption_CURLOPT_FOLLOWLOCATION: CURLoption = 52;
pub const CURLoption_CURLOPT_TRANSFERTEXT: CURLoption = 53;
pub const CURLoption_CURLOPT_PUT: CURLoption = 54;
pub const CURLoption_CURLOPT_PROGRESSFUNCTION: CURLoption = 20056;
pub const CURLoption_CURLOPT_XFERINFODATA: CURLoption = 10057;
pub const CURLoption_CURLOPT_AUTOREFERER: CURLoption = 58;
pub const CURLoption_CURLOPT_PROXYPORT: CURLoption = 59;
pub const CURLoption_CURLOPT_POSTFIELDSIZE: CURLoption = 60;
pub const CURLoption_CURLOPT_HTTPPROXYTUNNEL: CURLoption = 61;
pub const CURLoption_CURLOPT_INTERFACE: CURLoption = 10062;
pub const CURLoption_CURLOPT_KRBLEVEL: CURLoption = 10063;
pub const CURLoption_CURLOPT_SSL_VERIFYPEER: CURLoption = 64;
pub const CURLoption_CURLOPT_CAINFO: CURLoption = 10065;
pub const CURLoption_CURLOPT_MAXREDIRS: CURLoption = 68;
pub const CURLoption_CURLOPT_FILETIME: CURLoption = 69;
pub const CURLoption_CURLOPT_TELNETOPTIONS: CURLoption = 10070;
pub const CURLoption_CURLOPT_MAXCONNECTS: CURLoption = 71;
pub const CURLoption_CURLOPT_OBSOLETE72: CURLoption = 72;
pub const CURLoption_CURLOPT_FRESH_CONNECT: CURLoption = 74;
pub const CURLoption_CURLOPT_FORBID_REUSE: CURLoption = 75;
pub const CURLoption_CURLOPT_RANDOM_FILE: CURLoption = 10076;
pub const CURLoption_CURLOPT_EGDSOCKET: CURLoption = 10077;
pub const CURLoption_CURLOPT_CONNECTTIMEOUT: CURLoption = 78;
pub const CURLoption_CURLOPT_HEADERFUNCTION: CURLoption = 20079;
pub const CURLoption_CURLOPT_HTTPGET: CURLoption = 80;
pub const CURLoption_CURLOPT_SSL_VERIFYHOST: CURLoption = 81;
pub const CURLoption_CURLOPT_COOKIEJAR: CURLoption = 10082;
pub const CURLoption_CURLOPT_SSL_CIPHER_LIST: CURLoption = 10083;
pub const CURLoption_CURLOPT_HTTP_VERSION: CURLoption = 84;
pub const CURLoption_CURLOPT_FTP_USE_EPSV: CURLoption = 85;
pub const CURLoption_CURLOPT_SSLCERTTYPE: CURLoption = 10086;
pub const CURLoption_CURLOPT_SSLKEY: CURLoption = 10087;
pub const CURLoption_CURLOPT_SSLKEYTYPE: CURLoption = 10088;
pub const CURLoption_CURLOPT_SSLENGINE: CURLoption = 10089;
pub const CURLoption_CURLOPT_SSLENGINE_DEFAULT: CURLoption = 90;
pub const CURLoption_CURLOPT_DNS_USE_GLOBAL_CACHE: CURLoption = 91;
pub const CURLoption_CURLOPT_DNS_CACHE_TIMEOUT: CURLoption = 92;
pub const CURLoption_CURLOPT_PREQUOTE: CURLoption = 10093;
pub const CURLoption_CURLOPT_DEBUGFUNCTION: CURLoption = 20094;
pub const CURLoption_CURLOPT_DEBUGDATA: CURLoption = 10095;
pub const CURLoption_CURLOPT_COOKIESESSION: CURLoption = 96;
pub const CURLoption_CURLOPT_CAPATH: CURLoption = 10097;
pub const CURLoption_CURLOPT_BUFFERSIZE: CURLoption = 98;
pub const CURLoption_CURLOPT_NOSIGNAL: CURLoption = 99;
pub const CURLoption_CURLOPT_SHARE: CURLoption = 10100;
pub const CURLoption_CURLOPT_PROXYTYPE: CURLoption = 101;
pub const CURLoption_CURLOPT_ACCEPT_ENCODING: CURLoption = 10102;
pub const CURLoption_CURLOPT_PRIVATE: CURLoption = 10103;
pub const CURLoption_CURLOPT_HTTP200ALIASES: CURLoption = 10104;
pub const CURLoption_CURLOPT_UNRESTRICTED_AUTH: CURLoption = 105;
pub const CURLoption_CURLOPT_FTP_USE_EPRT: CURLoption = 106;
pub const CURLoption_CURLOPT_HTTPAUTH: CURLoption = 107;
pub const CURLoption_CURLOPT_SSL_CTX_FUNCTION: CURLoption = 20108;
pub const CURLoption_CURLOPT_SSL_CTX_DATA: CURLoption = 10109;
pub const CURLoption_CURLOPT_FTP_CREATE_MISSING_DIRS: CURLoption = 110;
pub const CURLoption_CURLOPT_PROXYAUTH: CURLoption = 111;
pub const CURLoption_CURLOPT_SERVER_RESPONSE_TIMEOUT: CURLoption = 112;
pub const CURLoption_CURLOPT_IPRESOLVE: CURLoption = 113;
pub const CURLoption_CURLOPT_MAXFILESIZE: CURLoption = 114;
pub const CURLoption_CURLOPT_INFILESIZE_LARGE: CURLoption = 30115;
pub const CURLoption_CURLOPT_RESUME_FROM_LARGE: CURLoption = 30116;
pub const CURLoption_CURLOPT_MAXFILESIZE_LARGE: CURLoption = 30117;
pub const CURLoption_CURLOPT_NETRC_FILE: CURLoption = 10118;
pub const CURLoption_CURLOPT_USE_SSL: CURLoption = 119;
pub const CURLoption_CURLOPT_POSTFIELDSIZE_LARGE: CURLoption = 30120;
pub const CURLoption_CURLOPT_TCP_NODELAY: CURLoption = 121;
pub const CURLoption_CURLOPT_FTPSSLAUTH: CURLoption = 129;
pub const CURLoption_CURLOPT_IOCTLFUNCTION: CURLoption = 20130;
pub const CURLoption_CURLOPT_IOCTLDATA: CURLoption = 10131;
pub const CURLoption_CURLOPT_FTP_ACCOUNT: CURLoption = 10134;
pub const CURLoption_CURLOPT_COOKIELIST: CURLoption = 10135;
pub const CURLoption_CURLOPT_IGNORE_CONTENT_LENGTH: CURLoption = 136;
pub const CURLoption_CURLOPT_FTP_SKIP_PASV_IP: CURLoption = 137;
pub const CURLoption_CURLOPT_FTP_FILEMETHOD: CURLoption = 138;
pub const CURLoption_CURLOPT_LOCALPORT: CURLoption = 139;
pub const CURLoption_CURLOPT_LOCALPORTRANGE: CURLoption = 140;
pub const CURLoption_CURLOPT_CONNECT_ONLY: CURLoption = 141;
pub const CURLoption_CURLOPT_CONV_FROM_NETWORK_FUNCTION: CURLoption = 20142;
pub const CURLoption_CURLOPT_CONV_TO_NETWORK_FUNCTION: CURLoption = 20143;
pub const CURLoption_CURLOPT_CONV_FROM_UTF8_FUNCTION: CURLoption = 20144;
pub const CURLoption_CURLOPT_MAX_SEND_SPEED_LARGE: CURLoption = 30145;
pub const CURLoption_CURLOPT_MAX_RECV_SPEED_LARGE: CURLoption = 30146;
pub const CURLoption_CURLOPT_FTP_ALTERNATIVE_TO_USER: CURLoption = 10147;
pub const CURLoption_CURLOPT_SOCKOPTFUNCTION: CURLoption = 20148;
pub const CURLoption_CURLOPT_SOCKOPTDATA: CURLoption = 10149;
pub const CURLoption_CURLOPT_SSL_SESSIONID_CACHE: CURLoption = 150;
pub const CURLoption_CURLOPT_SSH_AUTH_TYPES: CURLoption = 151;
pub const CURLoption_CURLOPT_SSH_PUBLIC_KEYFILE: CURLoption = 10152;
pub const CURLoption_CURLOPT_SSH_PRIVATE_KEYFILE: CURLoption = 10153;
pub const CURLoption_CURLOPT_FTP_SSL_CCC: CURLoption = 154;
pub const CURLoption_CURLOPT_TIMEOUT_MS: CURLoption = 155;
pub const CURLoption_CURLOPT_CONNECTTIMEOUT_MS: CURLoption = 156;
pub const CURLoption_CURLOPT_HTTP_TRANSFER_DECODING: CURLoption = 157;
pub const CURLoption_CURLOPT_HTTP_CONTENT_DECODING: CURLoption = 158;
pub const CURLoption_CURLOPT_NEW_FILE_PERMS: CURLoption = 159;
pub const CURLoption_CURLOPT_NEW_DIRECTORY_PERMS: CURLoption = 160;
pub const CURLoption_CURLOPT_POSTREDIR: CURLoption = 161;
pub const CURLoption_CURLOPT_SSH_HOST_PUBLIC_KEY_MD5: CURLoption = 10162;
pub const CURLoption_CURLOPT_OPENSOCKETFUNCTION: CURLoption = 20163;
pub const CURLoption_CURLOPT_OPENSOCKETDATA: CURLoption = 10164;
pub const CURLoption_CURLOPT_COPYPOSTFIELDS: CURLoption = 10165;
pub const CURLoption_CURLOPT_PROXY_TRANSFER_MODE: CURLoption = 166;
pub const CURLoption_CURLOPT_SEEKFUNCTION: CURLoption = 20167;
pub const CURLoption_CURLOPT_SEEKDATA: CURLoption = 10168;
pub const CURLoption_CURLOPT_CRLFILE: CURLoption = 10169;
pub const CURLoption_CURLOPT_ISSUERCERT: CURLoption = 10170;
pub const CURLoption_CURLOPT_ADDRESS_SCOPE: CURLoption = 171;
pub const CURLoption_CURLOPT_CERTINFO: CURLoption = 172;
pub const CURLoption_CURLOPT_USERNAME: CURLoption = 10173;
pub const CURLoption_CURLOPT_PASSWORD: CURLoption = 10174;
pub const CURLoption_CURLOPT_PROXYUSERNAME: CURLoption = 10175;
pub const CURLoption_CURLOPT_PROXYPASSWORD: CURLoption = 10176;
pub const CURLoption_CURLOPT_NOPROXY: CURLoption = 10177;
pub const CURLoption_CURLOPT_TFTP_BLKSIZE: CURLoption = 178;
pub const CURLoption_CURLOPT_SOCKS5_GSSAPI_SERVICE: CURLoption = 10179;
pub const CURLoption_CURLOPT_SOCKS5_GSSAPI_NEC: CURLoption = 180;
pub const CURLoption_CURLOPT_PROTOCOLS: CURLoption = 181;
pub const CURLoption_CURLOPT_REDIR_PROTOCOLS: CURLoption = 182;
pub const CURLoption_CURLOPT_SSH_KNOWNHOSTS: CURLoption = 10183;
pub const CURLoption_CURLOPT_SSH_KEYFUNCTION: CURLoption = 20184;
pub const CURLoption_CURLOPT_SSH_KEYDATA: CURLoption = 10185;
pub const CURLoption_CURLOPT_MAIL_FROM: CURLoption = 10186;
pub const CURLoption_CURLOPT_MAIL_RCPT: CURLoption = 10187;
pub const CURLoption_CURLOPT_FTP_USE_PRET: CURLoption = 188;
pub const CURLoption_CURLOPT_RTSP_REQUEST: CURLoption = 189;
pub const CURLoption_CURLOPT_RTSP_SESSION_ID: CURLoption = 10190;
pub const CURLoption_CURLOPT_RTSP_STREAM_URI: CURLoption = 10191;
pub const CURLoption_CURLOPT_RTSP_TRANSPORT: CURLoption = 10192;
pub const CURLoption_CURLOPT_RTSP_CLIENT_CSEQ: CURLoption = 193;
pub const CURLoption_CURLOPT_RTSP_SERVER_CSEQ: CURLoption = 194;
pub const CURLoption_CURLOPT_INTERLEAVEDATA: CURLoption = 10195;
pub const CURLoption_CURLOPT_INTERLEAVEFUNCTION: CURLoption = 20196;
pub const CURLoption_CURLOPT_WILDCARDMATCH: CURLoption = 197;
pub const CURLoption_CURLOPT_CHUNK_BGN_FUNCTION: CURLoption = 20198;
pub const CURLoption_CURLOPT_CHUNK_END_FUNCTION: CURLoption = 20199;
pub const CURLoption_CURLOPT_FNMATCH_FUNCTION: CURLoption = 20200;
pub const CURLoption_CURLOPT_CHUNK_DATA: CURLoption = 10201;
pub const CURLoption_CURLOPT_FNMATCH_DATA: CURLoption = 10202;
pub const CURLoption_CURLOPT_RESOLVE: CURLoption = 10203;
pub const CURLoption_CURLOPT_TLSAUTH_USERNAME: CURLoption = 10204;
pub const CURLoption_CURLOPT_TLSAUTH_PASSWORD: CURLoption = 10205;
pub const CURLoption_CURLOPT_TLSAUTH_TYPE: CURLoption = 10206;
pub const CURLoption_CURLOPT_TRANSFER_ENCODING: CURLoption = 207;
pub const CURLoption_CURLOPT_CLOSESOCKETFUNCTION: CURLoption = 20208;
pub const CURLoption_CURLOPT_CLOSESOCKETDATA: CURLoption = 10209;
pub const CURLoption_CURLOPT_GSSAPI_DELEGATION: CURLoption = 210;
pub const CURLoption_CURLOPT_DNS_SERVERS: CURLoption = 10211;
pub const CURLoption_CURLOPT_ACCEPTTIMEOUT_MS: CURLoption = 212;
pub const CURLoption_CURLOPT_TCP_KEEPALIVE: CURLoption = 213;
pub const CURLoption_CURLOPT_TCP_KEEPIDLE: CURLoption = 214;
pub const CURLoption_CURLOPT_TCP_KEEPINTVL: CURLoption = 215;
pub const CURLoption_CURLOPT_SSL_OPTIONS: CURLoption = 216;
pub const CURLoption_CURLOPT_MAIL_AUTH: CURLoption = 10217;
pub const CURLoption_CURLOPT_SASL_IR: CURLoption = 218;
pub const CURLoption_CURLOPT_XFERINFOFUNCTION: CURLoption = 20219;
pub const CURLoption_CURLOPT_XOAUTH2_BEARER: CURLoption = 10220;
pub const CURLoption_CURLOPT_DNS_INTERFACE: CURLoption = 10221;
pub const CURLoption_CURLOPT_DNS_LOCAL_IP4: CURLoption = 10222;
pub const CURLoption_CURLOPT_DNS_LOCAL_IP6: CURLoption = 10223;
pub const CURLoption_CURLOPT_LOGIN_OPTIONS: CURLoption = 10224;
pub const CURLoption_CURLOPT_SSL_ENABLE_NPN: CURLoption = 225;
pub const CURLoption_CURLOPT_SSL_ENABLE_ALPN: CURLoption = 226;
pub const CURLoption_CURLOPT_EXPECT_100_TIMEOUT_MS: CURLoption = 227;
pub const CURLoption_CURLOPT_PROXYHEADER: CURLoption = 10228;
pub const CURLoption_CURLOPT_HEADEROPT: CURLoption = 229;
pub const CURLoption_CURLOPT_PINNEDPUBLICKEY: CURLoption = 10230;
pub const CURLoption_CURLOPT_UNIX_SOCKET_PATH: CURLoption = 10231;
pub const CURLoption_CURLOPT_SSL_VERIFYSTATUS: CURLoption = 232;
pub const CURLoption_CURLOPT_SSL_FALSESTART: CURLoption = 233;
pub const CURLoption_CURLOPT_PATH_AS_IS: CURLoption = 234;
pub const CURLoption_CURLOPT_PROXY_SERVICE_NAME: CURLoption = 10235;
pub const CURLoption_CURLOPT_SERVICE_NAME: CURLoption = 10236;
pub const CURLoption_CURLOPT_PIPEWAIT: CURLoption = 237;
pub const CURLoption_CURLOPT_DEFAULT_PROTOCOL: CURLoption = 10238;
pub const CURLoption_CURLOPT_STREAM_WEIGHT: CURLoption = 239;
pub const CURLoption_CURLOPT_STREAM_DEPENDS: CURLoption = 10240;
pub const CURLoption_CURLOPT_STREAM_DEPENDS_E: CURLoption = 10241;
pub const CURLoption_CURLOPT_TFTP_NO_OPTIONS: CURLoption = 242;
pub const CURLoption_CURLOPT_CONNECT_TO: CURLoption = 10243;
pub const CURLoption_CURLOPT_TCP_FASTOPEN: CURLoption = 244;
pub const CURLoption_CURLOPT_KEEP_SENDING_ON_ERROR: CURLoption = 245;
pub const CURLoption_CURLOPT_PROXY_CAINFO: CURLoption = 10246;
pub const CURLoption_CURLOPT_PROXY_CAPATH: CURLoption = 10247;
pub const CURLoption_CURLOPT_PROXY_SSL_VERIFYPEER: CURLoption = 248;
pub const CURLoption_CURLOPT_PROXY_SSL_VERIFYHOST: CURLoption = 249;
pub const CURLoption_CURLOPT_PROXY_SSLVERSION: CURLoption = 250;
pub const CURLoption_CURLOPT_PROXY_TLSAUTH_USERNAME: CURLoption = 10251;
pub const CURLoption_CURLOPT_PROXY_TLSAUTH_PASSWORD: CURLoption = 10252;
pub const CURLoption_CURLOPT_PROXY_TLSAUTH_TYPE: CURLoption = 10253;
pub const CURLoption_CURLOPT_PROXY_SSLCERT: CURLoption = 10254;
pub const CURLoption_CURLOPT_PROXY_SSLCERTTYPE: CURLoption = 10255;
pub const CURLoption_CURLOPT_PROXY_SSLKEY: CURLoption = 10256;
pub const CURLoption_CURLOPT_PROXY_SSLKEYTYPE: CURLoption = 10257;
pub const CURLoption_CURLOPT_PROXY_KEYPASSWD: CURLoption = 10258;
pub const CURLoption_CURLOPT_PROXY_SSL_CIPHER_LIST: CURLoption = 10259;
pub const CURLoption_CURLOPT_PROXY_CRLFILE: CURLoption = 10260;
pub const CURLoption_CURLOPT_PROXY_SSL_OPTIONS: CURLoption = 261;
pub const CURLoption_CURLOPT_PRE_PROXY: CURLoption = 10262;
pub const CURLoption_CURLOPT_PROXY_PINNEDPUBLICKEY: CURLoption = 10263;
pub const CURLoption_CURLOPT_ABSTRACT_UNIX_SOCKET: CURLoption = 10264;
pub const CURLoption_CURLOPT_SUPPRESS_CONNECT_HEADERS: CURLoption = 265;
pub const CURLoption_CURLOPT_REQUEST_TARGET: CURLoption = 10266;
pub const CURLoption_CURLOPT_SOCKS5_AUTH: CURLoption = 267;
pub const CURLoption_CURLOPT_SSH_COMPRESSION: CURLoption = 268;
pub const CURLoption_CURLOPT_MIMEPOST: CURLoption = 10269;
pub const CURLoption_CURLOPT_TIMEVALUE_LARGE: CURLoption = 30270;
pub const CURLoption_CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS: CURLoption = 271;
pub const CURLoption_CURLOPT_RESOLVER_START_FUNCTION: CURLoption = 20272;
pub const CURLoption_CURLOPT_RESOLVER_START_DATA: CURLoption = 10273;
pub const CURLoption_CURLOPT_HAPROXYPROTOCOL: CURLoption = 274;
pub const CURLoption_CURLOPT_DNS_SHUFFLE_ADDRESSES: CURLoption = 275;
pub const CURLoption_CURLOPT_TLS13_CIPHERS: CURLoption = 10276;
pub const CURLoption_CURLOPT_PROXY_TLS13_CIPHERS: CURLoption = 10277;
pub const CURLoption_CURLOPT_DISALLOW_USERNAME_IN_URL: CURLoption = 278;
pub const CURLoption_CURLOPT_DOH_URL: CURLoption = 10279;
pub const CURLoption_CURLOPT_UPLOAD_BUFFERSIZE: CURLoption = 280;
pub const CURLoption_CURLOPT_UPKEEP_INTERVAL_MS: CURLoption = 281;
pub const CURLoption_CURLOPT_CURLU: CURLoption = 10282;
pub const CURLoption_CURLOPT_TRAILERFUNCTION: CURLoption = 20283;
pub const CURLoption_CURLOPT_TRAILERDATA: CURLoption = 10284;
pub const CURLoption_CURLOPT_HTTP09_ALLOWED: CURLoption = 285;
pub const CURLoption_CURLOPT_ALTSVC_CTRL: CURLoption = 286;
pub const CURLoption_CURLOPT_ALTSVC: CURLoption = 10287;
pub const CURLoption_CURLOPT_MAXAGE_CONN: CURLoption = 288;
pub const CURLoption_CURLOPT_SASL_AUTHZID: CURLoption = 10289;
pub const CURLoption_CURLOPT_MAIL_RCPT_ALLOWFAILS: CURLoption = 290;
pub const CURLoption_CURLOPT_SSLCERT_BLOB: CURLoption = 40291;
pub const CURLoption_CURLOPT_SSLKEY_BLOB: CURLoption = 40292;
pub const CURLoption_CURLOPT_PROXY_SSLCERT_BLOB: CURLoption = 40293;
pub const CURLoption_CURLOPT_PROXY_SSLKEY_BLOB: CURLoption = 40294;
pub const CURLoption_CURLOPT_ISSUERCERT_BLOB: CURLoption = 40295;
pub const CURLoption_CURLOPT_PROXY_ISSUERCERT: CURLoption = 10296;
pub const CURLoption_CURLOPT_PROXY_ISSUERCERT_BLOB: CURLoption = 40297;
pub const CURLoption_CURLOPT_SSL_EC_CURVES: CURLoption = 10298;
pub const CURLoption_CURLOPT_HSTS_CTRL: CURLoption = 299;
pub const CURLoption_CURLOPT_HSTS: CURLoption = 10300;
pub const CURLoption_CURLOPT_HSTSREADFUNCTION: CURLoption = 20301;
pub const CURLoption_CURLOPT_HSTSREADDATA: CURLoption = 10302;
pub const CURLoption_CURLOPT_HSTSWRITEFUNCTION: CURLoption = 20303;
pub const CURLoption_CURLOPT_HSTSWRITEDATA: CURLoption = 10304;
pub const CURLoption_CURLOPT_AWS_SIGV4: CURLoption = 10305;
pub const CURLoption_CURLOPT_DOH_SSL_VERIFYPEER: CURLoption = 306;
pub const CURLoption_CURLOPT_DOH_SSL_VERIFYHOST: CURLoption = 307;
pub const CURLoption_CURLOPT_DOH_SSL_VERIFYSTATUS: CURLoption = 308;
pub const CURLoption_CURLOPT_CAINFO_BLOB: CURLoption = 40309;
pub const CURLoption_CURLOPT_PROXY_CAINFO_BLOB: CURLoption = 40310;
pub const CURLoption_CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256: CURLoption = 10311;
pub const CURLoption_CURLOPT_PREREQFUNCTION: CURLoption = 20312;
pub const CURLoption_CURLOPT_PREREQDATA: CURLoption = 10313;
pub const CURLoption_CURLOPT_MAXLIFETIME_CONN: CURLoption = 314;
pub const CURLoption_CURLOPT_MIME_OPTIONS: CURLoption = 315;
pub const CURLoption_CURLOPT_SSH_HOSTKEYFUNCTION: CURLoption = 20316;
pub const CURLoption_CURLOPT_SSH_HOSTKEYDATA: CURLoption = 10317;
pub const CURLoption_CURLOPT_PROTOCOLS_STR: CURLoption = 10318;
pub const CURLoption_CURLOPT_REDIR_PROTOCOLS_STR: CURLoption = 10319;
pub const CURLoption_CURLOPT_WS_OPTIONS: CURLoption = 320;
pub const CURLoption_CURLOPT_CA_CACHE_TIMEOUT: CURLoption = 321;
pub const CURLoption_CURLOPT_QUICK_EXIT: CURLoption = 322;
pub const CURLoption_CURLOPT_HAPROXY_CLIENT_IP: CURLoption = 10323;
pub const CURLoption_CURLOPT_LASTENTRY: CURLoption = 10324;
pub type CURLoption = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_strequal(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn curl_strnequal(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_mime {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_mimepart {
    _unused: [u8; 0],
}
extern "C" {
    pub fn curl_mime_init(easy: *mut CURL) -> *mut curl_mime;
}
extern "C" {
    pub fn curl_mime_free(mime: *mut curl_mime);
}
extern "C" {
    pub fn curl_mime_addpart(mime: *mut curl_mime) -> *mut curl_mimepart;
}
extern "C" {
    pub fn curl_mime_name(
        part: *mut curl_mimepart,
        name: *const ::std::os::raw::c_char,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_filename(
        part: *mut curl_mimepart,
        filename: *const ::std::os::raw::c_char,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_type(
        part: *mut curl_mimepart,
        mimetype: *const ::std::os::raw::c_char,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_encoder(
        part: *mut curl_mimepart,
        encoding: *const ::std::os::raw::c_char,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_data(
        part: *mut curl_mimepart,
        data: *const ::std::os::raw::c_char,
        datasize: usize,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_filedata(
        part: *mut curl_mimepart,
        filename: *const ::std::os::raw::c_char,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_data_cb(
        part: *mut curl_mimepart,
        datasize: curl_off_t,
        readfunc: curl_read_callback,
        seekfunc: curl_seek_callback,
        freefunc: curl_free_callback,
        arg: *mut ::std::os::raw::c_void,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_subparts(part: *mut curl_mimepart, subparts: *mut curl_mime) -> CURLcode;
}
extern "C" {
    pub fn curl_mime_headers(
        part: *mut curl_mimepart,
        headers: *mut curl_slist,
        take_ownership: ::std::os::raw::c_int,
    ) -> CURLcode;
}
pub const CURLFORMcode_CURL_FORMADD_OK: CURLFORMcode = 0;
pub const CURLFORMcode_CURL_FORMADD_MEMORY: CURLFORMcode = 1;
pub const CURLFORMcode_CURL_FORMADD_OPTION_TWICE: CURLFORMcode = 2;
pub const CURLFORMcode_CURL_FORMADD_NULL: CURLFORMcode = 3;
pub const CURLFORMcode_CURL_FORMADD_UNKNOWN_OPTION: CURLFORMcode = 4;
pub const CURLFORMcode_CURL_FORMADD_INCOMPLETE: CURLFORMcode = 5;
pub const CURLFORMcode_CURL_FORMADD_ILLEGAL_ARRAY: CURLFORMcode = 6;
pub const CURLFORMcode_CURL_FORMADD_DISABLED: CURLFORMcode = 7;
pub const CURLFORMcode_CURL_FORMADD_LAST: CURLFORMcode = 8;
pub type CURLFORMcode = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_formadd(
        httppost: *mut *mut curl_httppost,
        last_post: *mut *mut curl_httppost,
        ...
    ) -> CURLFORMcode;
}
pub type curl_formget_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> usize,
>;
extern "C" {
    pub fn curl_formget(
        form: *mut curl_httppost,
        arg: *mut ::std::os::raw::c_void,
        append: curl_formget_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn curl_formfree(form: *mut curl_httppost);
}
extern "C" {
    pub fn curl_getenv(variable: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_version() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_easy_escape(
        handle: *mut CURL,
        string: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_escape(
        string: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_easy_unescape(
        handle: *mut CURL,
        string: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        outlength: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_unescape(
        string: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_free(p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn curl_global_init(flags: ::std::os::raw::c_long) -> CURLcode;
}
extern "C" {
    pub fn curl_global_init_mem(
        flags: ::std::os::raw::c_long,
        m: curl_malloc_callback,
        f: curl_free_callback,
        r: curl_realloc_callback,
        s: curl_strdup_callback,
        c: curl_calloc_callback,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_global_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_slist {
    pub data: *mut ::std::os::raw::c_char,
    pub next: *mut curl_slist,
}
#[test]
fn bindgen_test_layout_curl_slist() {
    const UNINIT: ::std::mem::MaybeUninit<curl_slist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_slist>(),
        16usize,
        concat!("Size of: ", stringify!(curl_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_slist),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_slist),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_ssl_backend {
    pub id: curl_sslbackend,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_curl_ssl_backend() {
    const UNINIT: ::std::mem::MaybeUninit<curl_ssl_backend> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_ssl_backend>(),
        16usize,
        concat!("Size of: ", stringify!(curl_ssl_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_ssl_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_ssl_backend))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ssl_backend),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ssl_backend),
            "::",
            stringify!(name)
        )
    );
}
pub const CURLsslset_CURLSSLSET_OK: CURLsslset = 0;
pub const CURLsslset_CURLSSLSET_UNKNOWN_BACKEND: CURLsslset = 1;
pub const CURLsslset_CURLSSLSET_TOO_LATE: CURLsslset = 2;
pub const CURLsslset_CURLSSLSET_NO_BACKENDS: CURLsslset = 3;
pub type CURLsslset = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_global_sslset(
        id: curl_sslbackend,
        name: *const ::std::os::raw::c_char,
        avail: *mut *mut *const curl_ssl_backend,
    ) -> CURLsslset;
}
extern "C" {
    pub fn curl_slist_append(
        list: *mut curl_slist,
        data: *const ::std::os::raw::c_char,
    ) -> *mut curl_slist;
}
extern "C" {
    pub fn curl_slist_free_all(list: *mut curl_slist);
}
extern "C" {
    pub fn curl_getdate(p: *const ::std::os::raw::c_char, unused: *const time_t) -> time_t;
}
pub const CURLINFO_CURLINFO_NONE: CURLINFO = 0;
pub const CURLINFO_CURLINFO_EFFECTIVE_URL: CURLINFO = 1048577;
pub const CURLINFO_CURLINFO_RESPONSE_CODE: CURLINFO = 2097154;
pub const CURLINFO_CURLINFO_TOTAL_TIME: CURLINFO = 3145731;
pub const CURLINFO_CURLINFO_NAMELOOKUP_TIME: CURLINFO = 3145732;
pub const CURLINFO_CURLINFO_CONNECT_TIME: CURLINFO = 3145733;
pub const CURLINFO_CURLINFO_PRETRANSFER_TIME: CURLINFO = 3145734;
pub const CURLINFO_CURLINFO_SIZE_UPLOAD: CURLINFO = 3145735;
pub const CURLINFO_CURLINFO_SIZE_UPLOAD_T: CURLINFO = 6291463;
pub const CURLINFO_CURLINFO_SIZE_DOWNLOAD: CURLINFO = 3145736;
pub const CURLINFO_CURLINFO_SIZE_DOWNLOAD_T: CURLINFO = 6291464;
pub const CURLINFO_CURLINFO_SPEED_DOWNLOAD: CURLINFO = 3145737;
pub const CURLINFO_CURLINFO_SPEED_DOWNLOAD_T: CURLINFO = 6291465;
pub const CURLINFO_CURLINFO_SPEED_UPLOAD: CURLINFO = 3145738;
pub const CURLINFO_CURLINFO_SPEED_UPLOAD_T: CURLINFO = 6291466;
pub const CURLINFO_CURLINFO_HEADER_SIZE: CURLINFO = 2097163;
pub const CURLINFO_CURLINFO_REQUEST_SIZE: CURLINFO = 2097164;
pub const CURLINFO_CURLINFO_SSL_VERIFYRESULT: CURLINFO = 2097165;
pub const CURLINFO_CURLINFO_FILETIME: CURLINFO = 2097166;
pub const CURLINFO_CURLINFO_FILETIME_T: CURLINFO = 6291470;
pub const CURLINFO_CURLINFO_CONTENT_LENGTH_DOWNLOAD: CURLINFO = 3145743;
pub const CURLINFO_CURLINFO_CONTENT_LENGTH_DOWNLOAD_T: CURLINFO = 6291471;
pub const CURLINFO_CURLINFO_CONTENT_LENGTH_UPLOAD: CURLINFO = 3145744;
pub const CURLINFO_CURLINFO_CONTENT_LENGTH_UPLOAD_T: CURLINFO = 6291472;
pub const CURLINFO_CURLINFO_STARTTRANSFER_TIME: CURLINFO = 3145745;
pub const CURLINFO_CURLINFO_CONTENT_TYPE: CURLINFO = 1048594;
pub const CURLINFO_CURLINFO_REDIRECT_TIME: CURLINFO = 3145747;
pub const CURLINFO_CURLINFO_REDIRECT_COUNT: CURLINFO = 2097172;
pub const CURLINFO_CURLINFO_PRIVATE: CURLINFO = 1048597;
pub const CURLINFO_CURLINFO_HTTP_CONNECTCODE: CURLINFO = 2097174;
pub const CURLINFO_CURLINFO_HTTPAUTH_AVAIL: CURLINFO = 2097175;
pub const CURLINFO_CURLINFO_PROXYAUTH_AVAIL: CURLINFO = 2097176;
pub const CURLINFO_CURLINFO_OS_ERRNO: CURLINFO = 2097177;
pub const CURLINFO_CURLINFO_NUM_CONNECTS: CURLINFO = 2097178;
pub const CURLINFO_CURLINFO_SSL_ENGINES: CURLINFO = 4194331;
pub const CURLINFO_CURLINFO_COOKIELIST: CURLINFO = 4194332;
pub const CURLINFO_CURLINFO_LASTSOCKET: CURLINFO = 2097181;
pub const CURLINFO_CURLINFO_FTP_ENTRY_PATH: CURLINFO = 1048606;
pub const CURLINFO_CURLINFO_REDIRECT_URL: CURLINFO = 1048607;
pub const CURLINFO_CURLINFO_PRIMARY_IP: CURLINFO = 1048608;
pub const CURLINFO_CURLINFO_APPCONNECT_TIME: CURLINFO = 3145761;
pub const CURLINFO_CURLINFO_CERTINFO: CURLINFO = 4194338;
pub const CURLINFO_CURLINFO_CONDITION_UNMET: CURLINFO = 2097187;
pub const CURLINFO_CURLINFO_RTSP_SESSION_ID: CURLINFO = 1048612;
pub const CURLINFO_CURLINFO_RTSP_CLIENT_CSEQ: CURLINFO = 2097189;
pub const CURLINFO_CURLINFO_RTSP_SERVER_CSEQ: CURLINFO = 2097190;
pub const CURLINFO_CURLINFO_RTSP_CSEQ_RECV: CURLINFO = 2097191;
pub const CURLINFO_CURLINFO_PRIMARY_PORT: CURLINFO = 2097192;
pub const CURLINFO_CURLINFO_LOCAL_IP: CURLINFO = 1048617;
pub const CURLINFO_CURLINFO_LOCAL_PORT: CURLINFO = 2097194;
pub const CURLINFO_CURLINFO_TLS_SESSION: CURLINFO = 4194347;
pub const CURLINFO_CURLINFO_ACTIVESOCKET: CURLINFO = 5242924;
pub const CURLINFO_CURLINFO_TLS_SSL_PTR: CURLINFO = 4194349;
pub const CURLINFO_CURLINFO_HTTP_VERSION: CURLINFO = 2097198;
pub const CURLINFO_CURLINFO_PROXY_SSL_VERIFYRESULT: CURLINFO = 2097199;
pub const CURLINFO_CURLINFO_PROTOCOL: CURLINFO = 2097200;
pub const CURLINFO_CURLINFO_SCHEME: CURLINFO = 1048625;
pub const CURLINFO_CURLINFO_TOTAL_TIME_T: CURLINFO = 6291506;
pub const CURLINFO_CURLINFO_NAMELOOKUP_TIME_T: CURLINFO = 6291507;
pub const CURLINFO_CURLINFO_CONNECT_TIME_T: CURLINFO = 6291508;
pub const CURLINFO_CURLINFO_PRETRANSFER_TIME_T: CURLINFO = 6291509;
pub const CURLINFO_CURLINFO_STARTTRANSFER_TIME_T: CURLINFO = 6291510;
pub const CURLINFO_CURLINFO_REDIRECT_TIME_T: CURLINFO = 6291511;
pub const CURLINFO_CURLINFO_APPCONNECT_TIME_T: CURLINFO = 6291512;
pub const CURLINFO_CURLINFO_RETRY_AFTER: CURLINFO = 6291513;
pub const CURLINFO_CURLINFO_EFFECTIVE_METHOD: CURLINFO = 1048634;
pub const CURLINFO_CURLINFO_PROXY_ERROR: CURLINFO = 2097211;
pub const CURLINFO_CURLINFO_REFERER: CURLINFO = 1048636;
pub const CURLINFO_CURLINFO_CAINFO: CURLINFO = 1048637;
pub const CURLINFO_CURLINFO_CAPATH: CURLINFO = 1048638;
pub const CURLINFO_CURLINFO_XFER_ID: CURLINFO = 6291519;
pub const CURLINFO_CURLINFO_CONN_ID: CURLINFO = 6291520;
pub const CURLINFO_CURLINFO_LASTONE: CURLINFO = 64;
pub type CURLINFO = ::std::os::raw::c_int;
pub const CURLSHcode_CURLSHE_OK: CURLSHcode = 0;
pub const CURLSHcode_CURLSHE_BAD_OPTION: CURLSHcode = 1;
pub const CURLSHcode_CURLSHE_IN_USE: CURLSHcode = 2;
pub const CURLSHcode_CURLSHE_INVALID: CURLSHcode = 3;
pub const CURLSHcode_CURLSHE_NOMEM: CURLSHcode = 4;
pub const CURLSHcode_CURLSHE_NOT_BUILT_IN: CURLSHcode = 5;
pub const CURLSHcode_CURLSHE_LAST: CURLSHcode = 6;
pub type CURLSHcode = ::std::os::raw::c_int;
pub const CURLSHoption_CURLSHOPT_NONE: CURLSHoption = 0;
pub const CURLSHoption_CURLSHOPT_SHARE: CURLSHoption = 1;
pub const CURLSHoption_CURLSHOPT_UNSHARE: CURLSHoption = 2;
pub const CURLSHoption_CURLSHOPT_LOCKFUNC: CURLSHoption = 3;
pub const CURLSHoption_CURLSHOPT_UNLOCKFUNC: CURLSHoption = 4;
pub const CURLSHoption_CURLSHOPT_USERDATA: CURLSHoption = 5;
pub const CURLSHoption_CURLSHOPT_LAST: CURLSHoption = 6;
pub type CURLSHoption = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_share_init() -> *mut CURLSH;
}
extern "C" {
    pub fn curl_share_setopt(share: *mut CURLSH, option: CURLSHoption, ...) -> CURLSHcode;
}
extern "C" {
    pub fn curl_share_cleanup(share: *mut CURLSH) -> CURLSHcode;
}
pub const CURLversion_CURLVERSION_FIRST: CURLversion = 0;
pub const CURLversion_CURLVERSION_SECOND: CURLversion = 1;
pub const CURLversion_CURLVERSION_THIRD: CURLversion = 2;
pub const CURLversion_CURLVERSION_FOURTH: CURLversion = 3;
pub const CURLversion_CURLVERSION_FIFTH: CURLversion = 4;
pub const CURLversion_CURLVERSION_SIXTH: CURLversion = 5;
pub const CURLversion_CURLVERSION_SEVENTH: CURLversion = 6;
pub const CURLversion_CURLVERSION_EIGHTH: CURLversion = 7;
pub const CURLversion_CURLVERSION_NINTH: CURLversion = 8;
pub const CURLversion_CURLVERSION_TENTH: CURLversion = 9;
pub const CURLversion_CURLVERSION_ELEVENTH: CURLversion = 10;
pub const CURLversion_CURLVERSION_LAST: CURLversion = 11;
#[doc = " Structures for querying information about the curl library at runtime."]
pub type CURLversion = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_version_info_data {
    pub age: CURLversion,
    pub version: *const ::std::os::raw::c_char,
    pub version_num: ::std::os::raw::c_uint,
    pub host: *const ::std::os::raw::c_char,
    pub features: ::std::os::raw::c_int,
    pub ssl_version: *const ::std::os::raw::c_char,
    pub ssl_version_num: ::std::os::raw::c_long,
    pub libz_version: *const ::std::os::raw::c_char,
    pub protocols: *const *const ::std::os::raw::c_char,
    pub ares: *const ::std::os::raw::c_char,
    pub ares_num: ::std::os::raw::c_int,
    pub libidn: *const ::std::os::raw::c_char,
    pub iconv_ver_num: ::std::os::raw::c_int,
    pub libssh_version: *const ::std::os::raw::c_char,
    pub brotli_ver_num: ::std::os::raw::c_uint,
    pub brotli_version: *const ::std::os::raw::c_char,
    pub nghttp2_ver_num: ::std::os::raw::c_uint,
    pub nghttp2_version: *const ::std::os::raw::c_char,
    pub quic_version: *const ::std::os::raw::c_char,
    pub cainfo: *const ::std::os::raw::c_char,
    pub capath: *const ::std::os::raw::c_char,
    pub zstd_ver_num: ::std::os::raw::c_uint,
    pub zstd_version: *const ::std::os::raw::c_char,
    pub hyper_version: *const ::std::os::raw::c_char,
    pub gsasl_version: *const ::std::os::raw::c_char,
    pub feature_names: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_curl_version_info_data() {
    const UNINIT: ::std::mem::MaybeUninit<curl_version_info_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_version_info_data>(),
        208usize,
        concat!("Size of: ", stringify!(curl_version_info_data))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_version_info_data>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_version_info_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(age)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_num) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(version_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssl_version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(ssl_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssl_version_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(ssl_version_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).libz_version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(libz_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocols) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ares) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(ares)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ares_num) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(ares_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).libidn) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(libidn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iconv_ver_num) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(iconv_ver_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).libssh_version) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(libssh_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brotli_ver_num) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(brotli_ver_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brotli_version) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(brotli_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nghttp2_ver_num) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(nghttp2_ver_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nghttp2_version) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(nghttp2_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quic_version) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(quic_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cainfo) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(cainfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capath) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(capath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zstd_ver_num) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(zstd_ver_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zstd_version) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(zstd_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hyper_version) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(hyper_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsasl_version) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(gsasl_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_names) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_version_info_data),
            "::",
            stringify!(feature_names)
        )
    );
}
extern "C" {
    pub fn curl_version_info(arg1: CURLversion) -> *mut curl_version_info_data;
}
extern "C" {
    pub fn curl_easy_strerror(arg1: CURLcode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_share_strerror(arg1: CURLSHcode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_easy_pause(handle: *mut CURL, bitmask: ::std::os::raw::c_int) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_init() -> *mut CURL;
}
extern "C" {
    pub fn curl_easy_setopt(curl: *mut CURL, option: CURLoption, ...) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_perform(curl: *mut CURL) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_cleanup(curl: *mut CURL);
}
extern "C" {
    pub fn curl_easy_getinfo(curl: *mut CURL, info: CURLINFO, ...) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_duphandle(curl: *mut CURL) -> *mut CURL;
}
extern "C" {
    pub fn curl_easy_reset(curl: *mut CURL);
}
extern "C" {
    pub fn curl_easy_recv(
        curl: *mut CURL,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
        n: *mut usize,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_send(
        curl: *mut CURL,
        buffer: *const ::std::os::raw::c_void,
        buflen: usize,
        n: *mut usize,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_easy_upkeep(curl: *mut CURL) -> CURLcode;
}
pub type CURLM = ::std::os::raw::c_void;
pub const CURLMcode_CURLM_CALL_MULTI_PERFORM: CURLMcode = -1;
pub const CURLMcode_CURLM_OK: CURLMcode = 0;
pub const CURLMcode_CURLM_BAD_HANDLE: CURLMcode = 1;
pub const CURLMcode_CURLM_BAD_EASY_HANDLE: CURLMcode = 2;
pub const CURLMcode_CURLM_OUT_OF_MEMORY: CURLMcode = 3;
pub const CURLMcode_CURLM_INTERNAL_ERROR: CURLMcode = 4;
pub const CURLMcode_CURLM_BAD_SOCKET: CURLMcode = 5;
pub const CURLMcode_CURLM_UNKNOWN_OPTION: CURLMcode = 6;
pub const CURLMcode_CURLM_ADDED_ALREADY: CURLMcode = 7;
pub const CURLMcode_CURLM_RECURSIVE_API_CALL: CURLMcode = 8;
pub const CURLMcode_CURLM_WAKEUP_FAILURE: CURLMcode = 9;
pub const CURLMcode_CURLM_BAD_FUNCTION_ARGUMENT: CURLMcode = 10;
pub const CURLMcode_CURLM_ABORTED_BY_CALLBACK: CURLMcode = 11;
pub const CURLMcode_CURLM_UNRECOVERABLE_POLL: CURLMcode = 12;
pub const CURLMcode_CURLM_LAST: CURLMcode = 13;
pub type CURLMcode = ::std::os::raw::c_int;
pub const CURLMSG_CURLMSG_NONE: CURLMSG = 0;
pub const CURLMSG_CURLMSG_DONE: CURLMSG = 1;
pub const CURLMSG_CURLMSG_LAST: CURLMSG = 2;
pub type CURLMSG = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CURLMsg {
    pub msg: CURLMSG,
    pub easy_handle: *mut CURL,
    pub data: CURLMsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CURLMsg__bindgen_ty_1 {
    pub whatever: *mut ::std::os::raw::c_void,
    pub result: CURLcode,
}
#[test]
fn bindgen_test_layout_CURLMsg__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CURLMsg__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CURLMsg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CURLMsg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CURLMsg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CURLMsg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).whatever) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CURLMsg__bindgen_ty_1),
            "::",
            stringify!(whatever)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CURLMsg__bindgen_ty_1),
            "::",
            stringify!(result)
        )
    );
}
#[test]
fn bindgen_test_layout_CURLMsg() {
    const UNINIT: ::std::mem::MaybeUninit<CURLMsg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CURLMsg>(),
        24usize,
        concat!("Size of: ", stringify!(CURLMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<CURLMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(CURLMsg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CURLMsg),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).easy_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CURLMsg),
            "::",
            stringify!(easy_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CURLMsg),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_waitfd {
    pub fd: curl_socket_t,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_curl_waitfd() {
    const UNINIT: ::std::mem::MaybeUninit<curl_waitfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_waitfd>(),
        16usize,
        concat!("Size of: ", stringify!(curl_waitfd))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_waitfd>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_waitfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_waitfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_waitfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_waitfd),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    pub fn curl_multi_init() -> *mut CURLM;
}
extern "C" {
    pub fn curl_multi_add_handle(multi_handle: *mut CURLM, curl_handle: *mut CURL) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_remove_handle(multi_handle: *mut CURLM, curl_handle: *mut CURL) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_fdset(
        multi_handle: *mut CURLM,
        read_fd_set: *mut fd_set,
        write_fd_set: *mut fd_set,
        exc_fd_set: *mut fd_set,
        max_fd: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_wait(
        multi_handle: *mut CURLM,
        extra_fds: *mut curl_waitfd,
        extra_nfds: ::std::os::raw::c_uint,
        timeout_ms: ::std::os::raw::c_int,
        ret: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_poll(
        multi_handle: *mut CURLM,
        extra_fds: *mut curl_waitfd,
        extra_nfds: ::std::os::raw::c_uint,
        timeout_ms: ::std::os::raw::c_int,
        ret: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_wakeup(multi_handle: *mut CURLM) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_perform(
        multi_handle: *mut CURLM,
        running_handles: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_cleanup(multi_handle: *mut CURLM) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_info_read(
        multi_handle: *mut CURLM,
        msgs_in_queue: *mut ::std::os::raw::c_int,
    ) -> *mut CURLMsg;
}
extern "C" {
    pub fn curl_multi_strerror(arg1: CURLMcode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_multi_socket(
        multi_handle: *mut CURLM,
        s: curl_socket_t,
        running_handles: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_socket_action(
        multi_handle: *mut CURLM,
        s: curl_socket_t,
        ev_bitmask: ::std::os::raw::c_int,
        running_handles: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_socket_all(
        multi_handle: *mut CURLM,
        running_handles: *mut ::std::os::raw::c_int,
    ) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_timeout(
        multi_handle: *mut CURLM,
        milliseconds: *mut ::std::os::raw::c_long,
    ) -> CURLMcode;
}
pub const CURLMoption_CURLMOPT_SOCKETFUNCTION: CURLMoption = 20001;
pub const CURLMoption_CURLMOPT_SOCKETDATA: CURLMoption = 10002;
pub const CURLMoption_CURLMOPT_PIPELINING: CURLMoption = 3;
pub const CURLMoption_CURLMOPT_TIMERFUNCTION: CURLMoption = 20004;
pub const CURLMoption_CURLMOPT_TIMERDATA: CURLMoption = 10005;
pub const CURLMoption_CURLMOPT_MAXCONNECTS: CURLMoption = 6;
pub const CURLMoption_CURLMOPT_MAX_HOST_CONNECTIONS: CURLMoption = 7;
pub const CURLMoption_CURLMOPT_MAX_PIPELINE_LENGTH: CURLMoption = 8;
pub const CURLMoption_CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE: CURLMoption = 30009;
pub const CURLMoption_CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE: CURLMoption = 30010;
pub const CURLMoption_CURLMOPT_PIPELINING_SITE_BL: CURLMoption = 10011;
pub const CURLMoption_CURLMOPT_PIPELINING_SERVER_BL: CURLMoption = 10012;
pub const CURLMoption_CURLMOPT_MAX_TOTAL_CONNECTIONS: CURLMoption = 13;
pub const CURLMoption_CURLMOPT_PUSHFUNCTION: CURLMoption = 20014;
pub const CURLMoption_CURLMOPT_PUSHDATA: CURLMoption = 10015;
pub const CURLMoption_CURLMOPT_MAX_CONCURRENT_STREAMS: CURLMoption = 16;
pub const CURLMoption_CURLMOPT_LASTENTRY: CURLMoption = 17;
pub type CURLMoption = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_multi_setopt(multi_handle: *mut CURLM, option: CURLMoption, ...) -> CURLMcode;
}
extern "C" {
    pub fn curl_multi_assign(
        multi_handle: *mut CURLM,
        sockfd: curl_socket_t,
        sockp: *mut ::std::os::raw::c_void,
    ) -> CURLMcode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_pushheaders {
    _unused: [u8; 0],
}
extern "C" {
    pub fn curl_pushheader_bynum(
        h: *mut curl_pushheaders,
        num: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn curl_pushheader_byname(
        h: *mut curl_pushheaders,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub const CURLUcode_CURLUE_OK: CURLUcode = 0;
pub const CURLUcode_CURLUE_BAD_HANDLE: CURLUcode = 1;
pub const CURLUcode_CURLUE_BAD_PARTPOINTER: CURLUcode = 2;
pub const CURLUcode_CURLUE_MALFORMED_INPUT: CURLUcode = 3;
pub const CURLUcode_CURLUE_BAD_PORT_NUMBER: CURLUcode = 4;
pub const CURLUcode_CURLUE_UNSUPPORTED_SCHEME: CURLUcode = 5;
pub const CURLUcode_CURLUE_URLDECODE: CURLUcode = 6;
pub const CURLUcode_CURLUE_OUT_OF_MEMORY: CURLUcode = 7;
pub const CURLUcode_CURLUE_USER_NOT_ALLOWED: CURLUcode = 8;
pub const CURLUcode_CURLUE_UNKNOWN_PART: CURLUcode = 9;
pub const CURLUcode_CURLUE_NO_SCHEME: CURLUcode = 10;
pub const CURLUcode_CURLUE_NO_USER: CURLUcode = 11;
pub const CURLUcode_CURLUE_NO_PASSWORD: CURLUcode = 12;
pub const CURLUcode_CURLUE_NO_OPTIONS: CURLUcode = 13;
pub const CURLUcode_CURLUE_NO_HOST: CURLUcode = 14;
pub const CURLUcode_CURLUE_NO_PORT: CURLUcode = 15;
pub const CURLUcode_CURLUE_NO_QUERY: CURLUcode = 16;
pub const CURLUcode_CURLUE_NO_FRAGMENT: CURLUcode = 17;
pub const CURLUcode_CURLUE_NO_ZONEID: CURLUcode = 18;
pub const CURLUcode_CURLUE_BAD_FILE_URL: CURLUcode = 19;
pub const CURLUcode_CURLUE_BAD_FRAGMENT: CURLUcode = 20;
pub const CURLUcode_CURLUE_BAD_HOSTNAME: CURLUcode = 21;
pub const CURLUcode_CURLUE_BAD_IPV6: CURLUcode = 22;
pub const CURLUcode_CURLUE_BAD_LOGIN: CURLUcode = 23;
pub const CURLUcode_CURLUE_BAD_PASSWORD: CURLUcode = 24;
pub const CURLUcode_CURLUE_BAD_PATH: CURLUcode = 25;
pub const CURLUcode_CURLUE_BAD_QUERY: CURLUcode = 26;
pub const CURLUcode_CURLUE_BAD_SCHEME: CURLUcode = 27;
pub const CURLUcode_CURLUE_BAD_SLASHES: CURLUcode = 28;
pub const CURLUcode_CURLUE_BAD_USER: CURLUcode = 29;
pub const CURLUcode_CURLUE_LACKS_IDN: CURLUcode = 30;
pub const CURLUcode_CURLUE_LAST: CURLUcode = 31;
pub type CURLUcode = ::std::os::raw::c_int;
pub const CURLUPart_CURLUPART_URL: CURLUPart = 0;
pub const CURLUPart_CURLUPART_SCHEME: CURLUPart = 1;
pub const CURLUPart_CURLUPART_USER: CURLUPart = 2;
pub const CURLUPart_CURLUPART_PASSWORD: CURLUPart = 3;
pub const CURLUPart_CURLUPART_OPTIONS: CURLUPart = 4;
pub const CURLUPart_CURLUPART_HOST: CURLUPart = 5;
pub const CURLUPart_CURLUPART_PORT: CURLUPart = 6;
pub const CURLUPart_CURLUPART_PATH: CURLUPart = 7;
pub const CURLUPart_CURLUPART_QUERY: CURLUPart = 8;
pub const CURLUPart_CURLUPART_FRAGMENT: CURLUPart = 9;
pub const CURLUPart_CURLUPART_ZONEID: CURLUPart = 10;
pub type CURLUPart = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Curl_URL {
    _unused: [u8; 0],
}
pub type CURLU = Curl_URL;
extern "C" {
    pub fn curl_url() -> *mut CURLU;
}
extern "C" {
    pub fn curl_url_cleanup(handle: *mut CURLU);
}
extern "C" {
    pub fn curl_url_dup(in_: *const CURLU) -> *mut CURLU;
}
extern "C" {
    pub fn curl_url_get(
        handle: *const CURLU,
        what: CURLUPart,
        part: *mut *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CURLUcode;
}
extern "C" {
    pub fn curl_url_set(
        handle: *mut CURLU,
        what: CURLUPart,
        part: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CURLUcode;
}
extern "C" {
    pub fn curl_url_strerror(arg1: CURLUcode) -> *const ::std::os::raw::c_char;
}
pub const curl_easytype_CURLOT_LONG: curl_easytype = 0;
pub const curl_easytype_CURLOT_VALUES: curl_easytype = 1;
pub const curl_easytype_CURLOT_OFF_T: curl_easytype = 2;
pub const curl_easytype_CURLOT_OBJECT: curl_easytype = 3;
pub const curl_easytype_CURLOT_STRING: curl_easytype = 4;
pub const curl_easytype_CURLOT_SLIST: curl_easytype = 5;
pub const curl_easytype_CURLOT_CBPTR: curl_easytype = 6;
pub const curl_easytype_CURLOT_BLOB: curl_easytype = 7;
pub const curl_easytype_CURLOT_FUNCTION: curl_easytype = 8;
pub type curl_easytype = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_easyoption {
    pub name: *const ::std::os::raw::c_char,
    pub id: CURLoption,
    pub type_: curl_easytype,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_curl_easyoption() {
    const UNINIT: ::std::mem::MaybeUninit<curl_easyoption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_easyoption>(),
        24usize,
        concat!("Size of: ", stringify!(curl_easyoption))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_easyoption>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_easyoption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_easyoption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_easyoption),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_easyoption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_easyoption),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn curl_easy_option_by_name(name: *const ::std::os::raw::c_char) -> *const curl_easyoption;
}
extern "C" {
    pub fn curl_easy_option_by_id(id: CURLoption) -> *const curl_easyoption;
}
extern "C" {
    pub fn curl_easy_option_next(prev: *const curl_easyoption) -> *const curl_easyoption;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_header {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub amount: usize,
    pub index: usize,
    pub origin: ::std::os::raw::c_uint,
    pub anchor: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_curl_header() {
    const UNINIT: ::std::mem::MaybeUninit<curl_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_header>(),
        48usize,
        concat!("Size of: ", stringify!(curl_header))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_header>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anchor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_header),
            "::",
            stringify!(anchor)
        )
    );
}
pub const CURLHcode_CURLHE_OK: CURLHcode = 0;
pub const CURLHcode_CURLHE_BADINDEX: CURLHcode = 1;
pub const CURLHcode_CURLHE_MISSING: CURLHcode = 2;
pub const CURLHcode_CURLHE_NOHEADERS: CURLHcode = 3;
pub const CURLHcode_CURLHE_NOREQUEST: CURLHcode = 4;
pub const CURLHcode_CURLHE_OUT_OF_MEMORY: CURLHcode = 5;
pub const CURLHcode_CURLHE_BAD_ARGUMENT: CURLHcode = 6;
pub const CURLHcode_CURLHE_NOT_BUILT_IN: CURLHcode = 7;
pub type CURLHcode = ::std::os::raw::c_int;
extern "C" {
    pub fn curl_easy_header(
        easy: *mut CURL,
        name: *const ::std::os::raw::c_char,
        index: usize,
        origin: ::std::os::raw::c_uint,
        request: ::std::os::raw::c_int,
        hout: *mut *mut curl_header,
    ) -> CURLHcode;
}
extern "C" {
    pub fn curl_easy_nextheader(
        easy: *mut CURL,
        origin: ::std::os::raw::c_uint,
        request: ::std::os::raw::c_int,
        prev: *mut curl_header,
    ) -> *mut curl_header;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_ws_frame {
    pub age: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub offset: curl_off_t,
    pub bytesleft: curl_off_t,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_curl_ws_frame() {
    const UNINIT: ::std::mem::MaybeUninit<curl_ws_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<curl_ws_frame>(),
        32usize,
        concat!("Size of: ", stringify!(curl_ws_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<curl_ws_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(curl_ws_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ws_frame),
            "::",
            stringify!(age)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ws_frame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ws_frame),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesleft) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ws_frame),
            "::",
            stringify!(bytesleft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(curl_ws_frame),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn curl_ws_recv(
        curl: *mut CURL,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
        recv: *mut usize,
        metap: *mut *const curl_ws_frame,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_ws_send(
        curl: *mut CURL,
        buffer: *const ::std::os::raw::c_void,
        buflen: usize,
        sent: *mut usize,
        framesize: curl_off_t,
        sendflags: ::std::os::raw::c_uint,
    ) -> CURLcode;
}
extern "C" {
    pub fn curl_ws_meta(curl: *mut CURL) -> *const curl_ws_frame;
}
